# receiver.py
import socket
import time
import math
import sys
import select
import threading
#//////////////////////////////////////////////////////////////////////
#initialize all value

LA_y=0
LA_x=0
RA_x=0
RA_y=0
left_shoulder_y=0
left_shoulder_x=0
right_shoulder_x=0
right_shoulder_y=0
anchor_la_y=0
anchor_la_x=0
anchor_ra_y=0
anchor_ra_x=0
max_arm_y_step_range=200
max_arm_x_step_range=100
max_leg_y_step_range=200
max_head_y_step_range=100
LA_x_step_count=0 #initialize value for testing, later can be an input from motion capture
LA_y_step_count=0
RA_x_step_count=0 #initialize value for testing, later can be an input from motion capture
RA_y_step_count=0
lf_y_step_count=0
Rf_y_step_count=0
command_done = threading.Event()
calibration_done = threading.Event()
move_stepper_done=threading.Event()
A_pose_reset_done=threading.Event()

#//////////////////////////////////////////////////////////////////////////////
def handle_client(conn, addr):
    global LA_x
    global LA_y
    global RA_x
    global RA_y
    global ls_x
    global ls_y
    global rs_x
    global rs_y
    global head_y, lh_y, rh_y, lf_y, rf_y
    print(f"[+] Connection from {addr}")
    buffer = ""

    try:
        while True:
            data = conn.recv(1024).decode()
            if not data:
                break
            buffer += data
            while "\n" in buffer:
                line, buffer = buffer.split("\n", 1)
                print("[Received]", line)

                try:
                    head_str, x_str, y_str, ls_x_str, ls_y_str, ra_x_str, ra_y_str, rs_x_str, rs_y_str,lh_y_str, rh_y_str, lf_y_str, rf_y_str = line.strip().split(",")
                    head_y = int(head_str)
                    LA_x = int(x_str)
                    LA_y = int(y_str)
                    ls_x = int(ls_x_str)
                    ls_y = int(ls_y_str)
                    RA_x = int(ra_x_str)
                    RA_y = int(ra_y_str)
                    rs_x = int(rs_x_str) 
                    rs_y = int(rs_y_str)
                    lh_y = int(lh_y_str)
                    rh_y = int(rh_y_str)
                    lf_y = int(lf_y_str)
                    rf_y = int(rf_y_str)
                    print(f"[Parsed] LA_x = {LA_x}, LA_y = {LA_y}, LS_x = {ls_x}, LS_y = {ls_y}, RA_x={RA_x}, RA_y={RA_y}, RS_x = {rs_x}, RS_y = {rs_y},LH_y = {lh_y}, RH_y = {rh_y}, LF_y = {lf_y}, RF_y = {rf_y}")
                except ValueError:
                    print("[Warning] Malformed message:", line)

    except Exception as e:
        print("[Error]", e)
    finally:
        conn.close()
        print(f"[-] Connection from {addr} closed")
        
# Main server setup
HOST = '0.0.0.0'
PORT = 5000

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind((HOST, PORT))
server.listen()


def client_restart():
	while True:
	    conn, addr = server.accept()
	    # Start a new thread for each client
	    client_thread = threading.Thread(target=handle_client, args=(conn, addr))
	    client_thread.start()

def mode_select():
    while True:
        if not command_done.is_set():  # Only prompt if not calibrating
            Mode = input("Enter mode (C/S/Q): ").lower()
            if Mode == 'c':
                print('Calibration started')
                command_done.set()
                calibration_done.clear()
                threading.Thread(target=calibration).start()
            elif Mode == 's':
                print('Mirroring started')
                command_done.set()
                move_stepper_done.clear()
                threading.Thread(target=move_stepper).start()
            elif Mode == 'q':
                print('quit and reset to A pose')
                command_done.set()
                A_pose_reset_done.clear()
                threading.Thread(target=A_pose_reset).start()
                
client_restart_thread=threading.Thread(target=client_restart)  
client_restart_thread.start()              
mode_select_thread = threading.Thread(target=mode_select)
mode_select_thread.start()
        
def calibration():
    global head_y
    global LA_x, LA_y, RA_x, RA_y
    global ls_x, ls_y, rs_x, rs_y
    global lh_y, rh_y, lf_y, rf_y
    global left_shoulder_x, left_shoulder_y , right_shoulder_x , right_shoulder_y, left_hip_y, right_hip_y
    global anchor_head_y, anchor_la_x, anchor_la_y, anchor_ra_x, anchor_ra_y, anchor_lf_y, anchor_rf_y
    global max_LA_x_range, max_LA_y_range, max_RA_x_range, max_RA_y_range
    global left_arm_length,right_arm_length, right_leg_height, left_leg_height
    global LA_x_step_count, LA_y_step_count, RA_x_step_count, RA_y_step_count, lf_y_step_count, rf_y_step_count 
    if not calibration_done.is_set():
        anchor_head_y= head_y
        anchor_la_x=LA_x
        anchor_la_y=LA_y
        anchor_ra_x=RA_x
        anchor_ra_y=RA_y
        anchor_lf_y=lf_y
        anchor_rf_y=rf_y
        left_shoulder_x=ls_x
        left_shoulder_y=ls_y
        right_shoulder_x=rs_x
        right_shoulder_y=rs_y
        left_hip_y=lh_y
        right_hip_y=rh_y
        left_arm_length=math.sqrt(abs(left_shoulder_x - LA_x)**2 +abs(left_shoulder_y - LA_y)**2)
        right_arm_length=math.sqrt(abs(right_shoulder_x - RA_x)**2 +abs(right_shoulder_y - RA_y)**2)
        left_leg_height = left_hip_y - anchor_lf_y
        right_leg_height = right_hip_y - anchor_rf_y
        max_LA_x_range = left_arm_length 
        max_LA_y_range = left_arm_length*2
        max_RA_x_range = right_arm_length 
        max_RA_y_range = right_arm_length*2
        LA_x_step_count=(abs(anchor_la_x - left_shoulder_x)/max_LA_x_range)*max_arm_x_step_range  #left_arm_a_pose_x_step
        LA_y_step_count=((abs(anchor_la_y- (left_shoulder_y + left_arm_length)))/max_LA_y_range)*max_arm_y_step_range #left_arm_a_pose_y_step
        RA_x_step_count= (abs(anchor_ra_x - right_shoulder_x)/max_RA_x_range)*max_arm_x_step_range #right_arm_a_pose_x_step
        RA_y_step_count=((abs(anchor_ra_y- (right_shoulder_y + right_arm_length)))/max_LA_y_range)*max_arm_y_step_range #right_arm_a_pose_y_step
        lf_y_step_count=((left_hip_y - anchor_lf_y)/left_leg_height)*max_leg_y_step_range
        rf_y_step_count=((right_hip_y- anchor_rf_y)/right_leg_height)*max_leg_y_step_range
        print(f"Calibrating... anchor_la_x: {anchor_la_x}, anchor_la_y: {anchor_la_y}, anchor_ra_x: {anchor_ra_x}, anchor_ra_y: {anchor_ra_y}, anchor_lf_y: {anchor_lf_y}, anchor_rf_y: {anchor_rf_y}")
        print(f"max_LA_x_range: {max_LA_x_range}, max_LA_y_range: {max_LA_y_range}")
        print(f"max_RA_x_range: {max_RA_x_range}, max_RA_y_range: {max_RA_y_range}")
        print(f"left_leg_height: {left_leg_height}, right_leg_height: {right_leg_height}")
        print("Calibration complete!")
        command_done.clear()  # Signal completion
        calibration_done.set()
def move_stepper(): 
    global LA_y
    global LA_x
    global left_arm_length , right_arm_length
    global LA_x_step_count , RA_x_step_count
    global LA_y_step_count , RA_y_step_count
    global lh_y, rh_y, lf_y, rf_y
    global left_hip_y, right_hip_y
    global max_arm_y_step_range
    global max_arm_x_step_range
    global left_shoulder_x, left_shoulder_y
    global max_LA_x_range
    global max_LA_y_range
    global lf_y_step_count
    global rf_y_step_count
    while not move_stepper_done.is_set():
        try:
            LA_x_step_count=(abs(LA_x - left_shoulder_x)/max_LA_x_range)*max_arm_x_step_range
            LA_y_step_count=((abs(LA_y- (left_shoulder_y + left_arm_length)))/max_LA_y_range)*max_arm_y_step_range
            RA_x_step_count= (abs(RA_x - right_shoulder_x)/max_RA_x_range)*max_arm_x_step_range
            RA_y_step_count=((abs(RA_y- (right_shoulder_y + right_arm_length)))/max_LA_y_range)*max_arm_y_step_range
            lf_y_step_count=((left_hip_y - lf_y)/left_leg_height)*max_leg_y_step_range
            rf_y_step_count=((right_hip_y- rf_y)/right_leg_height)*max_leg_y_step_range
            print(f"LA_x_step_count: {LA_x_step_count}, LA_y_step_count:  {LA_y_step_count}")
            print(f"RA_x_step_count: {RA_x_step_count}, RA_y_step_count:  {RA_y_step_count}")
        except (IndexError, AttributeError):
            # Keep the previous value if detection fails
            pass
        time.sleep(0.06)
        if sys.stdin in select.select([sys.stdin], [], [], 0)[0]:
            line = sys.stdin.readline()
            if line.strip() == 'r':
                print("Exiting loop.")
                move_stepper_done.set()
                command_done.clear()
    
def A_pose_reset():
    global LA_x_step_count, RA_x_step_count
    global LA_y_step_count, RA_y_step_count
    if not A_pose_reset_done.is_set():
        LA_x_step_count=0
        LA_y_step_count=0
        RA_x_step_count=0
        RA_y_step_count=0
        print("LA_x_step_count ", LA_x_step_count)
        print("LA_y_step_count ", LA_y_step_count)
        print("RA_x_step_count ", RA_x_step_count)
        print("RA_y_step_count ", RA_y_step_count)
        command_done.clear()
        A_pose_reset_done.set()
       
