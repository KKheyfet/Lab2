
import threading
import time
import math
import requests
import Jetson.GPIO as GPIO

# Shared variables
latest_y_value = 0.5
latest_x_value = 0.5
previous_LA_x, previous_LA_y= 0, 0
previous_RA_x, previous_RA_y= 0, 0



# for declaring port for stepper
Lax_Dir = 22
Lax_Step = 23
Lay_Dir = 17
Lay_Step = 18
CW = 1
CCW = 0
GPIO.setmode(GPIO.BOARD)
GPIO.setup(Lax_Dir, GPIO.OUT)
GPIO.setup(Lax_Step, GPIO.OUT)
GPIO.setup(Lay_Dir, GPIO.OUT)
GPIO.setup(Lay_Step, GPIO.OUT)


# get x and y from the motion capture 
def x_y_from_MC():
    while True:
        LA_x= requests.get("http://producer:5000/get_var_LA_x")
        LA_y= requests.get("http://producer:5000/get_var_LA_y")

x_y_from_MC_thread = threading.Thread(target=x_y_from_MC)
x_y_from_MC_thread.start()

# change mode depending in user input 
import threading
import time

def mode_select():
    while True:
        Mode = input("please enter mode: C is for calibration, S is to start mirroring motion, Q is to quit and restart")    
        if Mode.lower() == 'c':
            print('mode calibration is selected')
        if Mode.lower() == 's':
            print('mode mirroring is selected')
        if Mode.lower() == 'q':
            print('mode quit is selected, returning to A pose')
        
mode_select_thread = threading.Thread(target=mode_select)
mode_select_thread.start()
        


def A_pose():

def LA_y_detection_thread():
    global latest_y_value
    global previous_LA_y
    global LA_y
    while True:
        try:
            # Use the new keypoint detection function
            latest_y_value = LA_y
            if abs(latest_y_value - previous_LA_y) >0.04:
                if latest_y_value < previous_LA_y:
                    GPIO.output(Lay_Dir, CCW)
                    print("LAY_CCW")
                if latest_y_value > previous_LA_y:
                    print("LAY_CW")
                    GPIO.output(Lay_Dir, CW)
            time.sleep(0.1) #0.1 seconds for update delay
            previous_LA_y = latest_y_value
            
        except (IndexError, AttributeError):
            # Keep the previous value if detection fails
            pass
        time.sleep(0.06)

# Start pose detection thread
LA_y_thread = threading.Thread(target=LA_y_detection_thread)
LA_y_thread.start()

def LA_x_detection_thread():
    global latest_x_value
    global previous_LA_x
    global LA_x
    while True:
        try:
            latest_x_value = LA_x
            if abs(latest_x_value - previous_LA_x) >0.04:
                
                if latest_x_value < previous_LA_x:
                    GPIO.output(Lax_Dir, CCW)
                    print("LAX_CCW")
                if latest_x_value > previous_LA_x:
                    print("LAX_CW")
                    GPIO.output(Lax_Dir, CW)
            time.sleep(0.1) #0.1 seconds for update delay
            previous_LA_x = latest_x_value
            
        except (IndexError, AttributeError):
            # move stepper back into A pose
            pass
        time.sleep(0.06)
LA_x_thread = threading.Thread(target=LA_x_detection_thread)
LA_x_thread.start()

 
    





 
    
