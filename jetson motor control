import cv2
import random
from collections import deque
import threading
import time
import math
import Jetson.GPIO as GPIO

# Shared variables
latest_y_value = 0.5
latest_x_value = 0.5
previous_LA_x, previous_LA_y= 0, 0
previous_RA_x, previous_RA_y= 0, 0

Lax_Dir = 22
Lax_Step = 23
Lay_Dir = 17
Lay_Step = 18
CW = 1
CCW = 0

GPIO.setmode(GPIO.BCM)
GPIO.setup(Lax_Dir, GPIO.OUT)
GPIO.setup(Lax_Step, GPIO.OUT)
GPIO.setup(Lay_Dir, GPIO.OUT)
GPIO.setup(Lay_Step, GPIO.OUT)
stop_event=threading.Event()
stop_event1=threading.Event()




def move_stepper(): # for left arm y
    while not stop_event.is_set():
        for x in range(100):
            GPIO.output(Lax_Step, GPIO.HIGH)
            time.sleep(0.005/6)
            GPIO.output(Lax_Step, GPIO.LOW)
            time.sleep(0.005/6)
            
def start_stepper():
    global stepper_thread
    stop_event.clear()
    stepper_thread=threading.Thread(target=move_stepper)
    stepper_thread.start()
    
    
def move_stepper1(): # for left arm x
    while not stop_event1.is_set():
        for y in range(100):
            GPIO.output(Lay_Step, GPIO.HIGH)
            time.sleep(0.005/6)
            GPIO.output(Lay_Step, GPIO.LOW)
            time.sleep(0.005/6)
def start_stepper1():
    global stepper_thread1
    stop_event1.clear()
    stepper_thread1=threading.Thread(target=move_stepper1)
    stepper_thread1.start() 



def LA_y_detection_thread():
    global latest_y_value
    global previous_LA_y
    global LA_y
    while True:
        try:
            # Use the new keypoint detection function
            latest_y_value = LA_y
            if abs(latest_y_value - previous_LA_y) <=0.04:
                stop_event.set()
                stepper_thread.join()
                print("true")
            if abs(latest_y_value - previous_LA_y) >0.04:
                start_stepper()
                print(latest_y_value)
                print("false")
                if latest_y_value < previous_LA_y:
                    GPIO.output(Lay_Dir, CCW)
                    print("CCW")
                if latest_y_value > previous_LA_y:
                    print("CW")
                    GPIO.output(Lay_Dir, CW)
            time.sleep(0.1) #0.1 seconds for update delay
            previous_LA_y = latest_y_value
            
        except (IndexError, AttributeError):
            # Keep the previous value if detection fails
            pass
        time.sleep(0.06)

# Start pose detection thread
LA_y_thread = threading.Thread(target=LA_y_detection_thread)
LA_y_thread.start()

def LA_x_detection_thread():
    global latest_x_value
    global previous_LA_x
    global LA_x
    while True:
    
        try:
           
            latest_x_value = LA_x
            if abs(latest_x_value - previous_LA_x) <=0.04:
                stop_event1.set()
                stepper_thread1.join()
                print("xtrue")
            if abs(latest_x_value - previous_LA_x) >0.04:
                start_stepper1()
                print(latest_x_value)
                print("xfalse")
                if latest_x_value < previous_LA_x:
                    GPIO.output(Lax_Dir, CCW)
                    print("xCCW")
                if latest_x_value > previous_LA_x:
                    print("xCW")
                    GPIO.output(Lax_Dir, CW)
            time.sleep(0.1) #0.1 seconds for update delay
            previous_LA_x = latest_x_value
            
        except (IndexError, AttributeError):
            # move stepper back into A pose
            pass
        time.sleep(0.06)

# Start pose detection thread
LA_x_thread = threading.Thread(target=LA_x_detection_thread)
LA_x_thread.start()

 
    
